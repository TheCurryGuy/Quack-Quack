// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

// Looking for ways to speed up your queries, or scale easily with your serverless or edge functions?
// Try Prisma Accelerate: https://pris.ly/cli/accelerate-init

generator client {
  provider = "prisma-client-js"
  output   = "../generated/prisma"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

enum RegistrationStatus {
  PENDING
  APPROVED
  REJECTED
}

enum HackathonStatus {
  UPCOMING
  LIVE
  ENDED
}
model User {
  id    String @id @default(cuid())
  email String @unique
  name  String?
  image String?

  // NextAuth fields
  emailVerified DateTime?
  accounts      Account[]
  sessions      Session[]

  // RELATIONS: A user can be a member of many finalized teams.
  // An individual registration is now a direct relation, not through a join table.
  // A user can also have pending invites to join a team.
  teamMemberships         TeamMember[]
  individualRegistrations IndividualRegistration[]
  pendingInvites          PendingTeamMember[]      @relation("ClaimedByUser")
}

// NextAuth required models
model Account {
  id                String  @id @default(cuid())
  userId            String
  type              String
  provider          String
  providerAccountId String
  refresh_token     String? @db.Text
  access_token      String? @db.Text
  expires_at        Int?
  token_type        String?
  scope             String?
  id_token          String? @db.Text
  session_state     String?

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([provider, providerAccountId])
}

model Session {
  id           String   @id @default(cuid())
  sessionToken String   @unique
  userId       String
  expires      DateTime
  user         User     @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model VerificationToken {
  identifier String
  token      String   @unique
  expires    DateTime

  @@unique([identifier, token])
}

// Host model for hackathon organizers (manual creation)
model Host {
  id           String   @id @default(cuid())
  email        String   @unique
  passwordHash String
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt

  // RELATIONS: A host can create many hackathons.
  hackathons Hackathon[]
}

model Hackathon {
  id                   String          @id @default(cuid())
  name                 String
  body                 String // Markdown content
  logoUrl              String
  bannerUrl            String
  teamSize             Int
  startDate            DateTime
  durationHours        Int
  registrationDeadline DateTime
  supportEmail         String
  isRegistrationOpen   Boolean         @default(true)
  status               HackathonStatus @default(UPCOMING)
  actualStartTime      DateTime?

  hostId String
  host   Host   @relation(fields: [hostId], references: [id], onDelete: Cascade)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // RELATIONS: A hackathon has many team applications, individual applications, and finalized teams.
  teamRegistrations       TeamRegistration[]
  individualRegistrations IndividualRegistration[]
  teams                   Team[]
}

// --- NEW AND REVISED MODELS FOR REGISTRATION ---

// NEW MODEL: For Individual Registrations
model IndividualRegistration {
  id          String   @id @default(cuid())
  hackathonId String
  hackathon   Hackathon @relation(fields: [hackathonId], references: [id], onDelete: Cascade)

  userId String
  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)
  status RegistrationStatus @default(PENDING)

  // User's self-provided details for this specific event
  githubUrl    String
  portfolioUrl String?
  college      String
  year         Int

  // NEW FIELDS from your API
  profileScore Int
  eligibility  String

  createdAt DateTime @default(now())

  @@unique([hackathonId, userId]) // A user can only register individually for a hackathon once
}

// NEW MODEL: Represents a single "Team" application
model TeamRegistration {
  id          String   @id @default(cuid())
  teamName    String
  hackathonId String
  hackathon   Hackathon @relation(fields: [hackathonId], references: [id], onDelete: Cascade)

  status   RegistrationStatus @default(PENDING)
  leaderId String // ID of the user who filled out the form

  // RELATIONS: A team registration has many pending members.
  pendingMembers PendingTeamMember[]

  createdAt DateTime @default(now())

  @@unique([hackathonId, teamName]) // Team names must be unique per hackathon
}

// NEW MODEL: Holds the pre-filled data for teammates and their unique join token
model PendingTeamMember {
  id                 String           @id @default(cuid())
  teamRegistrationId String
  teamRegistration   TeamRegistration @relation(fields: [teamRegistrationId], references: [id], onDelete: Cascade)

  joinToken String @unique // The unique token for this member to claim their spot

  // The pre-filled data provided by the team leader
  name         String
  email        String
  githubUrl    String
  portfolioUrl String?
  college      String
  year         Int

  // This field links to a REAL user once they claim their spot with the token
  claimedByUserId String?
  claimedByUser   User?   @relation("ClaimedByUser", fields: [claimedByUserId], references: [id])

  createdAt DateTime @default(now())
}


// --- UNCHANGED MODELS FOR FINALIZED TEAMS AND SUBMISSIONS ---

// Represents an APPROVED and finalized team for a hackathon
model Team {
  id          String   @id @default(cuid())
  name        String
  bio         String?
  skills      String? // Could be comma-separated or JSON
  hackathonId String
  hackathon   Hackathon @relation(fields: [hackathonId], references: [id], onDelete: Cascade)

  // Relations
  members    TeamMember[]
  rank       Int?
  submission ProjectSubmission?
  
  @@unique([hackathonId, name]) // Prevent duplicate team names per hackathon
}

// Links a User to a finalized Team
model TeamMember {
  id     String @id @default(cuid())
  teamId String
  team   Team   @relation(fields: [teamId], references: [id], onDelete: Cascade)
  userId String
  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([teamId, userId])
}

model ProjectSubmission {
  id        String   @id @default(cuid())
  teamId    String   @unique // Each team has only one submission
  team      Team     @relation(fields: [teamId], references: [id], onDelete: Cascade)
  title     String
  about     String
  problem   String
  githubUrl String
  techStacks String[] // Array of strings
  aiScore   Float?
  createdAt DateTime @default(now())
}